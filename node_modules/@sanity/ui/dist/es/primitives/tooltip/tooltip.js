var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useCallback, useEffect, useState } from 'react';
import { usePopper } from 'react-popper';
import styled from 'styled-components';
import { Layer, Portal, useBoundaryElement } from '../../utils';
import { Card } from '../card';
import { TooltipArrow } from './tooltipArrow';
const Root = styled(Layer) `
  pointer-events: none;
`;
export function Tooltip(props) {
    const boundaryElementContext = useBoundaryElement();
    const { allowedAutoPlacements, boundaryElement = boundaryElementContext, children, content, disabled, fallbackPlacements, placement = 'bottom', portal: portalProp } = props, restProps = __rest(props, ["allowedAutoPlacements", "boundaryElement", "children", "content", "disabled", "fallbackPlacements", "placement", "portal"]);
    const [referenceElement, setReferenceElement] = useState(null);
    const [popperElement, setPopperElement] = useState(null);
    const [arrowElement, setArrowElement] = useState(null);
    const popper = usePopper(referenceElement, popperElement, {
        placement,
        modifiers: [
            {
                name: 'arrow',
                options: {
                    element: arrowElement,
                    padding: 4,
                },
            },
            {
                name: 'preventOverflow',
                options: {
                    altAxis: true,
                    boundary: boundaryElement || undefined,
                    padding: 4,
                },
            },
            {
                name: 'offset',
                options: { offset: [0, 3] },
            },
            {
                name: 'flip',
                options: {
                    allowedAutoPlacements,
                    fallbackPlacements,
                },
            },
        ],
    });
    const { forceUpdate } = popper;
    const [isOpen, setIsOpen] = useState(false);
    const handleBlur = useCallback(() => setIsOpen(false), []);
    const handleFocus = useCallback(() => setIsOpen(true), []);
    const handleMouseEnter = useCallback(() => setIsOpen(true), []);
    const handleMouseLeave = useCallback(() => setIsOpen(false), []);
    useEffect(() => {
        if (forceUpdate)
            forceUpdate();
    }, [forceUpdate, content]);
    if (disabled) {
        return children || React.createElement("span", null);
    }
    const popperNode = (React.createElement(Root, Object.assign({}, restProps, { ref: setPopperElement, style: popper.styles.popper }, popper.attributes.popper),
        React.createElement(Card, { radius: 2, shadow: 3 },
            content,
            React.createElement(TooltipArrow, { ref: setArrowElement, style: popper.styles.arrow }))));
    if (!children) {
        return React.createElement("span", null);
    }
    return (React.createElement(React.Fragment, null,
        React.cloneElement(children, {
            onBlur: handleBlur,
            onFocus: handleFocus,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            ref: setReferenceElement,
        }),
        isOpen && (React.createElement(React.Fragment, null,
            portalProp && React.createElement(Portal, null, popperNode),
            !portalProp && popperNode))));
}
//# sourceMappingURL=tooltip.js.map
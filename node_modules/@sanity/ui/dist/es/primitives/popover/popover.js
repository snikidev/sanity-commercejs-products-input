var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import maxSize from 'popper-max-size-modifier';
import React, { cloneElement, forwardRef, useEffect, useMemo, useState } from 'react';
import { usePopper } from 'react-popper';
import styled, { css } from 'styled-components';
import { Layer, Portal, useBoundaryElement, usePortal } from '../../utils';
import { Card } from '../card';
import { responsiveContainerWidthStyles } from '../container/styles';
import { PopoverArrow } from './arrow';
const Root = styled(Layer)(({ preventOverflow }) => css `
    pointer-events: none;
    display: flex;
    flex-direction: column;

    & > * {
      min-height: 0;
    }

    /* Hide the popover when the reference element is out of bounds */
    ${preventOverflow &&
    css `
      &[data-popper-reference-hidden='true'] {
        display: none;
      }
    `}
  `);
const PopoverCard = styled(Card)(({ constrainSize }) => css `
    flex: 1;
    max-height: ${constrainSize && '100%'};
    height: stretch;
    pointer-events: all;
    && {
      display: flex;
    }
    flex-direction: column;
    & > * {
      min-height: 0;
    }
    ${responsiveContainerWidthStyles}
  `);
const applyMaxSize = {
    name: 'applyMaxSize',
    enabled: true,
    phase: 'beforeWrite',
    requires: ['maxSize'],
    fn(opts) {
        const { state } = opts;
        const { width, height } = state.modifiersData.maxSize;
        state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), { maxWidth: `${width}px`, maxHeight: `${height}px` });
    },
};
export const Popover = forwardRef((props, ref) => {
    const boundaryElementContext = useBoundaryElement();
    const { allowedAutoPlacements, arrow = true, boundaryElement: boundaryElementProp = boundaryElementContext, children: child, content, constrainSize, disabled, fallbackPlacements, open, padding, placement: placementProp, portal: portalProp = true, preventOverflow, radius = 3, referenceElement: referenceElementProp, shadow = 3, scheme, style = {}, tone, width = 0 } = props, restProps = __rest(props, ["allowedAutoPlacements", "arrow", "boundaryElement", "children", "content", "constrainSize", "disabled", "fallbackPlacements", "open", "padding", "placement", "portal", "preventOverflow", "radius", "referenceElement", "shadow", "scheme", "style", "tone", "width"]);
    const placement = typeof placementProp === 'string' ? placementProp : 'bottom';
    const portal = usePortal();
    const boundaryElement = boundaryElementProp || portal.boundaryElement;
    const [referenceElement, setReferenceElement] = useState(null);
    const [popperElement, setPopperElement] = useState(null);
    const [arrowElement, setArrowElement] = useState(null);
    const popperReferenceElement = referenceElementProp || referenceElement;
    const customMaxSize = useMemo(() => (Object.assign(Object.assign({}, maxSize), { options: { boundary: boundaryElement || undefined, padding: 8 } })), [boundaryElement]);
    const modifiers = [
        constrainSize && customMaxSize,
        constrainSize && applyMaxSize,
        arrow && {
            name: 'arrow',
            options: {
                element: arrowElement,
                padding: 4,
            },
        },
        preventOverflow && {
            name: 'preventOverflow',
            options: {
                altAxis: true,
                boundary: boundaryElement || undefined,
                padding: 8,
            },
        },
        {
            name: 'offset',
            options: {
                offset: [0, 4],
            },
        },
        {
            name: 'flip',
            options: {
                allowedAutoPlacements,
                fallbackPlacements,
            },
        },
    ].filter(Boolean);
    const popper = usePopper(popperReferenceElement, popperElement, {
        placement,
        modifiers,
    });
    const { attributes, forceUpdate, styles } = popper;
    useEffect(() => {
        if (forceUpdate)
            forceUpdate();
    }, [content, forceUpdate, open, popperReferenceElement]);
    if (disabled) {
        return child || React.createElement(React.Fragment, null);
    }
    const setRef = (el) => {
        const childRef = child.ref;
        setReferenceElement(el);
        if (typeof childRef === 'function') {
            childRef(el);
        }
        else if (childRef) {
            childRef.current = el;
        }
    };
    const setRootRef = (el) => {
        setPopperElement(el);
        if (typeof ref === 'function')
            ref(el);
        else if (ref)
            ref.current = el;
    };
    const node = (React.createElement(Root, Object.assign({ "data-ui": "Popover" }, restProps, { preventOverflow: preventOverflow, ref: setRootRef, style: Object.assign(Object.assign({}, style), styles.popper) }, attributes.popper),
        React.createElement(PopoverCard, { constrainSize: constrainSize, "data-ui": "PopoverCard", padding: padding, radius: radius, scheme: scheme, shadow: shadow, tone: tone, width: width },
            arrow && React.createElement(PopoverArrow, { ref: setArrowElement, tone: "default", style: styles.arrow }),
            content)));
    return (React.createElement(React.Fragment, null,
        child && !referenceElementProp ? cloneElement(child, { ref: setRef }) : child || React.createElement(React.Fragment, null),
        open && (React.createElement(React.Fragment, null,
            portalProp && React.createElement(Portal, null, node),
            !portalProp && node))));
});
Popover.displayName = 'Popover';
//# sourceMappingURL=popover.js.map
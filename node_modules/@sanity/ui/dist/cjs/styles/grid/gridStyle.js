"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.responsiveGridStyle = void 0;
var helpers_1 = require("../helpers");
var GRID_CSS = { '&:not([hidden])': { display: 'grid' } };
var GRID_AUTO_COLUMS = {
    auto: 'auto',
    min: 'min-content',
    max: 'max-content',
    fr: 'minmax(0, 1fr)',
};
var GRID_AUTO_ROWS = {
    auto: 'auto',
    min: 'min-content',
    max: 'max-content',
    fr: 'minmax(0, 1fr)',
};
function responsiveGridStyle() {
    return [
        GRID_CSS,
        responsiveGridAutoFlowStyle,
        responsiveGridAutoRowsStyle,
        responsiveGridAutoColsStyle,
        responsiveGridColumnsStyle,
        responsiveGridRowsStyle,
        responsiveGridGapStyle,
        responsiveGridGapXStyle,
        responsiveGridGapYStyle,
    ];
}
exports.responsiveGridStyle = responsiveGridStyle;
function responsiveGridAutoFlowStyle(props) {
    var theme = props.theme;
    var media = theme.sanity.media;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.autoFlow), function (autoFlow) { return ({
        gridAutoFlow: autoFlow,
    }); });
}
function responsiveGridAutoRowsStyle(props) {
    var theme = props.theme;
    var media = theme.sanity.media;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.autoRows), function (autoRows) { return ({
        gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows],
    }); });
}
function responsiveGridAutoColsStyle(props) {
    var theme = props.theme;
    var media = theme.sanity.media;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.autoCols), function (autoCols) { return ({
        gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols],
    }); });
}
function responsiveGridColumnsStyle(props) {
    var theme = props.theme;
    var media = theme.sanity.media;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.columns), function (columns) { return ({
        gridTemplateColumns: columns && "repeat(" + columns + ",minmax(0,1fr));",
    }); });
}
function responsiveGridRowsStyle(props) {
    var theme = props.theme;
    var media = theme.sanity.media;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.rows), function (rows) { return ({
        gridTemplateRows: rows && "repeat(" + rows + ",minmax(0,1fr));",
    }); });
}
function responsiveGridGapStyle(props) {
    var theme = props.theme;
    var _a = theme.sanity, media = _a.media, space = _a.space;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.gap), function (gap) { return ({
        gridGap: gap ? helpers_1.rem(space[gap]) : undefined,
    }); });
}
function responsiveGridGapXStyle(props) {
    var theme = props.theme;
    var _a = theme.sanity, media = _a.media, space = _a.space;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.gapX), function (gapX) { return ({
        columnGap: gapX ? helpers_1.rem(space[gapX]) : undefined,
    }); });
}
function responsiveGridGapYStyle(props) {
    var theme = props.theme;
    var _a = theme.sanity, media = _a.media, space = _a.space;
    return helpers_1.responsive(media, helpers_1.getResponsiveProp(props.gapY), function (gapY) { return ({
        rowGap: gapY ? helpers_1.rem(space[gapY]) : undefined,
    }); });
}
//# sourceMappingURL=gridStyle.js.map
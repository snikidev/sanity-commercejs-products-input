"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _default = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _UnknownFields = _interopRequireDefault(require("../ObjectInput/styles/UnknownFields.css"));

var _PatchEvent = _interopRequireWildcard(require("../../PatchEvent"));

var _Warning = _interopRequireDefault(require("../Warning"));

var _converters = _interopRequireDefault(require("./converters"));

var _UntypedValueInput = require("./UntypedValueInput");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getConverters(value, actualType, validTypes) {
  if (!(actualType in _converters.default)) {
    return [];
  }

  return Object.keys(_converters.default[actualType]).filter(targetType => validTypes.includes(targetType)).map(targetType => _objectSpread({
    from: actualType,
    to: targetType
  }, _converters.default[actualType][targetType])).filter(converter => converter.test(value));
}

class InvalidValueInput extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "handleClearClick", () => {
      this.props.onChange(_PatchEvent.default.from((0, _PatchEvent.unset)()));
    });

    _defineProperty(this, "handleConvertTo", converted => {
      this.props.onChange(_PatchEvent.default.from((0, _PatchEvent.set)(converted)));
    });
  }

  renderValidTypes() {
    var validTypes = this.props.validTypes;

    if (validTypes.length === 1) {
      return /*#__PURE__*/_react.default.createElement("div", null, "Only content of type ", /*#__PURE__*/_react.default.createElement("code", null, validTypes[0]), " are valid here according to the schema. This could mean that the type has changed, or that someone else has added it to their own local schema that is not yet deployed.");
    }

    return /*#__PURE__*/_react.default.createElement("div", null, "Only the following types are valid here according to schema:", ' ', validTypes.map(validType => /*#__PURE__*/_react.default.createElement("li", {
      key: validType
    }, /*#__PURE__*/_react.default.createElement("code", null, validType))));
  }

  render() {
    var _this$props = this.props,
        value = _this$props.value,
        actualType = _this$props.actualType,
        validTypes = _this$props.validTypes,
        onChange = _this$props.onChange;

    if (typeof value === 'object' && value !== null && !('_type' in value)) {
      return /*#__PURE__*/_react.default.createElement(_UntypedValueInput.UntypedValueInput, {
        value: value,
        validTypes: validTypes,
        onChange: onChange
      });
    }

    var converters = getConverters(value, actualType, validTypes);

    var message = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Encountered a value of type ", /*#__PURE__*/_react.default.createElement("code", null, actualType), ".", this.renderValidTypes(), /*#__PURE__*/_react.default.createElement("h4", null, actualType), /*#__PURE__*/_react.default.createElement("pre", {
      className: _UnknownFields.default.inspectValue
    }, JSON.stringify(value, null, 2)), converters.map(converter => /*#__PURE__*/_react.default.createElement(_default.default, {
      key: "".concat(converter.from, "-").concat(converter.to),
      onClick: () => this.handleConvertTo(converter.convert(value)),
      color: "primary"
    }, "Convert value to ", converter.to)), /*#__PURE__*/_react.default.createElement("div", {
      className: _UnknownFields.default.buttonWrapper
    }, /*#__PURE__*/_react.default.createElement(_default.default, {
      onClick: this.handleClearClick,
      color: "danger"
    }, "Remove value")));

    return /*#__PURE__*/_react.default.createElement(_Warning.default, {
      heading: "Content has invalid type",
      message: message
    });
  }

}

exports.default = InvalidValueInput;
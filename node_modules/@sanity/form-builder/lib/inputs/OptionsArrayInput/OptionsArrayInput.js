"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _types = require("@sanity/types");

var _paths = require("@sanity/util/paths");

var _default = _interopRequireDefault(require("part:@sanity/components/fieldsets/default"));

var _PatchEvent = _interopRequireWildcard(require("../../PatchEvent"));

var _resolveTypeName = require("../../utils/resolveTypeName");

var _Warning = _interopRequireDefault(require("../Warning"));

var _Item = _interopRequireDefault(require("./Item"));

var _OptionsArrayInput = _interopRequireDefault(require("./styles/OptionsArrayInput.css"));

var _legacyOptionsSupport = require("./legacyOptionsSupport");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var changeIndicatorOptions = {
  compareDeep: true
};

function isEqual(item, otherItem) {
  if ((0, _legacyOptionsSupport.isLegacyOptionsItem)(item) || (0, _legacyOptionsSupport.isLegacyOptionsItem)(otherItem)) {
    return item.value === otherItem.value;
  }

  if (item === otherItem) {
    return true;
  }

  if (typeof item !== typeof otherItem) {
    return false;
  }

  if (typeof item !== 'object' && !Array.isArray(item)) {
    return item === otherItem;
  }

  if (item._key && item._key === otherItem._key) {
    return true;
  }

  if (Array.isArray(item)) {
    if (!item.length !== otherItem.length) {
      return false;
    }

    return item.every((it, i) => isEqual(item[i], otherItem[i]));
  }

  var keys = Object.keys(item);
  var otherKeys = Object.keys(item);

  if (keys.length !== otherKeys.length) {
    return false;
  }

  return keys.every(keyName => isEqual(item[keyName], otherItem[keyName]));
}

function inArray(array, candidate) {
  return array ? array.some(item => isEqual(item, candidate)) : false;
}

class OptionsArrayInput extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_element", void 0);

    _defineProperty(this, "handleChange", (isChecked, optionValue) => {
      var _this$props = this.props,
          type = _this$props.type,
          _this$props$value = _this$props.value,
          value = _this$props$value === void 0 ? [] : _this$props$value;
      var list = (0, _get2.default)(type.options, 'list');

      if (!isChecked && optionValue._key) {
        // This is an optimization that only works if list items are _keyed
        this.props.onChange(_PatchEvent.default.from((0, _PatchEvent.unset)([{
          _key: optionValue._key
        }])));
      }

      var nextValue = list.filter(item => isEqual(optionValue, item) ? isChecked : inArray(value, (0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(item))).map(_legacyOptionsSupport.resolveValueWithLegacyOptionsSupport);
      this.props.onChange(_PatchEvent.default.from(nextValue.length > 0 ? (0, _PatchEvent.set)(nextValue) : (0, _PatchEvent.unset)()));
    });

    _defineProperty(this, "setElement", el => {
      this._element = el;
    });

    _defineProperty(this, "handleFocus", () => {
      this.props.onFocus([_paths.FOCUS_TERMINATOR]);
    });

    _defineProperty(this, "renderInvalidOptions", options => {
      var invalidOptions = options.filter(option => !this.getMemberTypeOfItem(option)).map(option => (0, _resolveTypeName.resolveTypeName)((0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option)));
      var len = invalidOptions.length;

      var heading = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Found ", len === 1 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "an") : len, " invalid option ", len === 1 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "type") : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "types"));

      if (invalidOptions.length < 1) {
        return null;
      }

      return /*#__PURE__*/_react.default.createElement(_Warning.default, {
        heading: heading,
        values: invalidOptions
      });
    });
  }

  getMemberTypeOfItem(option) {
    var type = this.props.type;
    return type.of.find(memberType => memberType.name === (0, _resolveTypeName.resolveTypeName)((0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option)));
  }

  focus() {
    if (this._element) {
      this._element.focus();
    }
  }

  render() {
    var _type$options, _type$options2;

    var _this$props2 = this.props,
        type = _this$props2.type,
        markers = _this$props2.markers,
        value = _this$props2.value,
        level = _this$props2.level,
        readOnly = _this$props2.readOnly,
        presence = _this$props2.presence,
        onFocus = _this$props2.onFocus,
        onBlur = _this$props2.onBlur;
    var options = ((_type$options = type.options) === null || _type$options === void 0 ? void 0 : _type$options.list) || [];
    var direction = (_type$options2 = type.options) === null || _type$options2 === void 0 ? void 0 : _type$options2.direction; // vertical and horizontal

    return /*#__PURE__*/_react.default.createElement(_default.default, {
      ref: this.setElement,
      legend: type.title,
      description: type.description,
      markers: markers,
      presence: presence,
      level: level,
      onClick: this.handleFocus,
      changeIndicator: changeIndicatorOptions
    }, /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", {
      className: direction === 'vertical' ? _OptionsArrayInput.default.itemWrapperVertical : _OptionsArrayInput.default.itemWrapperHorizontal
    }, options.map((option, index) => {
      var optionType = this.getMemberTypeOfItem(option);

      if (!optionType) {
        return null;
      }

      var checked = inArray(value, (0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option));
      return /*#__PURE__*/_react.default.createElement("div", {
        className: direction === 'vertical' ? _OptionsArrayInput.default.itemVertical : undefined,
        key: (0, _types.isTitledListValue)(option) ? option._key || index : index
      }, /*#__PURE__*/_react.default.createElement(_Item.default, {
        type: optionType,
        readOnly: readOnly,
        value: option,
        checked: checked,
        onChange: this.handleChange,
        onBlur: onBlur,
        onFocus: onFocus
      }));
    })), this.renderInvalidOptions(options)));
  }

}

exports.default = OptionsArrayInput;
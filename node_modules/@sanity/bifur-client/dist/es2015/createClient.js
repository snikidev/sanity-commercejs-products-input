import { catchError, filter, finalize, map, mergeMap, share, switchMap, take, } from 'rxjs/operators';
import { defer, EMPTY, fromEvent, merge, of, partition, } from 'rxjs';
import { customAlphabet } from 'nanoid';
import { SUBSCRIBE_METHODS } from './methods';
// at 1000 IDs per second ~4 million years needed in order to have a 1% probability of at least one collision.
// => https://zelark.github.io/nano-id-cc/
const getNextRequestId = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-', 20);
const HEARTBEAT = 'â™¥';
function formatRequest(method, params, id) {
    return JSON.stringify({
        jsonrpc: '2.0',
        method,
        params,
        id,
    });
}
function tryParse(input) {
    try {
        return [null, JSON.parse(input)];
    }
    catch (error) {
        return [error];
    }
}
function addApiVersion(params, v) {
    return Object.assign(Object.assign({}, params), { apiVersion: v });
}
const finalizeWith = (finalizer$) => input$ => input$.pipe(finalize(() => finalizer$.pipe(catchError(() => EMPTY)).subscribe()));
export const createClient = (connection$) => {
    const [heartbeats$, responses$] = partition(connection$.pipe(switchMap(connection => fromEvent(connection, 'message'))), event => event.data === HEARTBEAT);
    const parsedResponses$ = responses$.pipe(mergeMap(response => {
        const [err, msg] = tryParse(response.data);
        if (err) {
            console.warn('Unable to parse message: %s', err.message);
            return EMPTY;
        }
        if (!msg || !msg.jsonrpc) {
            console.warn('Received empty or non-jsonrpc message: %s', msg);
            return EMPTY;
        }
        return of(msg);
    }), share());
    function call(method, params = {}) {
        const requestId = getNextRequestId();
        return connection$.pipe(take(1), mergeMap(ws => {
            return merge(parsedResponses$.pipe(filter(rpcResult => rpcResult.id === requestId), map(rpcResult => rpcResult.result)), defer(() => {
                ws.send(formatRequest(method, addApiVersion(params, 'v1'), requestId));
                return EMPTY;
            }));
        }));
    }
    // Will call the rpc method and return an observable that emits the first reply and then ends
    function requestMethod(method, params) {
        return call(method, params).pipe(take(1));
    }
    // Will call the rpc method with the '_subscribe' suffix and return an observable of all received messages and
    // keeps the subscription open forever/until unsubscribe
    function requestSubscribe(method, params) {
        return call(`${method}_subscribe`, params).pipe(take(1), mergeMap(subscriptionId => parsedResponses$.pipe(filter(message => message.method === `${method}_subscription` &&
            message.params.subscription === subscriptionId), map(message => message.params.result), finalizeWith(call(`${method}_unsubscribe`, { subscriptionId })))));
    }
    return {
        // heartbeat$ is a stream of date objects representing when the "last message was received"
        // it will keep the connection open until it is unsubscribed and can therefore be used to keep connection alive
        // between requests
        heartbeats: merge(heartbeats$, responses$).pipe(map(() => new Date())),
        request: (method, params) => isSubscribeMethod(method)
            ? requestSubscribe(method, params)
            : requestMethod(method, params),
    };
};
function isSubscribeMethod(method) {
    return SUBSCRIBE_METHODS.includes(method);
}

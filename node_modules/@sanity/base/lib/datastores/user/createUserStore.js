"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createUserStore;

var _rxjs = require("rxjs");

var _raf = _interopRequireDefault(require("raf"));

var _dataloader = _interopRequireDefault(require("dataloader"));

var _nanoPubsub = _interopRequireDefault(require("nano-pubsub"));

var _authenticationFetcher = _interopRequireDefault(require("part:@sanity/base/authentication-fetcher"));

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var userCache = {};
var userChannel = (0, _nanoPubsub.default)();
var errorChannel = (0, _nanoPubsub.default)();
var _initialFetched = false;
var _currentUser = null;
var _currentError = null;
userChannel.subscribe(val => {
  _currentUser = val;

  if (val) {
    var normalized = normalizeOwnUser(val);
    userCache.me = normalized;
    userCache[val.id] = normalized;
  }
});
errorChannel.subscribe(val => {
  _currentError = val;
});

function fetchInitial() {
  return _authenticationFetcher.default.getCurrentUser().then(user => userChannel.publish(user), err => errorChannel.publish(err));
}

function logout() {
  return _authenticationFetcher.default.logout().then(() => userChannel.publish(null), err => errorChannel.publish(err));
}

var currentUser = new _rxjs.Observable(observer => {
  if (_initialFetched) {
    var emitter = _currentError ? emitError : emitSnapshot;
    emitter(_currentError || _currentUser);
  } else {
    _initialFetched = true;
    fetchInitial();
  }

  var unsubUser = userChannel.subscribe(nextUser => emitSnapshot(nextUser));
  var unsubError = errorChannel.subscribe(err => emitError(err));

  var unsubscribe = () => {
    unsubUser();
    unsubError();
  };

  return unsubscribe;

  function emitError(error) {
    observer.next({
      type: 'error',
      error
    });
  }

  function emitSnapshot(user) {
    observer.next({
      type: 'snapshot',
      user
    });
  }
});
var userLoader = new _dataloader.default(loadUsers, {
  batchScheduleFn: cb => (0, _raf.default)(cb)
});

function loadUsers(_x) {
  return _loadUsers.apply(this, arguments);
}

function _loadUsers() {
  _loadUsers = _asyncToGenerator(function* (userIds) {
    var missingIds = userIds.filter(userId => !(userId in userCache));
    var users = [];

    if (missingIds.length > 0) {
      users = yield _client.default.request({
        uri: "/users/".concat(missingIds.join(',')),
        withCredentials: true
      }).then(arrayify);
      users.forEach(user => {
        userCache[user.id] = user;
      });
    }

    return userIds.map(userId => {
      // Try cache first
      if (userCache[userId]) {
        return userCache[userId];
      } // Look up from returned users


      return users.find(user => user.id === userId) || null;
    });
  });
  return _loadUsers.apply(this, arguments);
}

function _getUser(userId) {
  return userLoader.load(userId);
}

function _getUsers2(_x2) {
  return _getUsers.apply(this, arguments);
}

function _getUsers() {
  _getUsers = _asyncToGenerator(function* (ids) {
    var users = yield userLoader.loadMany(ids);
    return users.filter(isUser);
  });
  return _getUsers.apply(this, arguments);
}

function arrayify(users) {
  return Array.isArray(users) ? users : [users];
}

function isUser(thing) {
  return Boolean(thing && thing !== null && typeof thing.id === 'string');
}

function normalizeOwnUser(user) {
  return {
    id: user.id,
    displayName: user.name,
    imageUrl: user.profileImage
  };
}

var observableApi = {
  currentUser,
  getUser: userId => typeof userCache[userId] === 'undefined' ? (0, _rxjs.from)(_getUser(userId)) : (0, _rxjs.of)(userCache[userId]),
  getUsers: userIds => {
    var missingIds = userIds.filter(userId => !(userId in userCache));
    return missingIds.length === 0 ? (0, _rxjs.of)(userIds.map(userId => userCache[userId]).filter(isUser)) : (0, _rxjs.from)(_getUsers2(userIds));
  }
};

function createUserStore() {
  return {
    actions: {
      logout,
      retry: fetchInitial
    },
    currentUser,
    getUser: _getUser,
    getUsers: _getUsers2,
    observable: observableApi
  };
}